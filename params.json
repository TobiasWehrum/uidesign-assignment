{"name":"Written Report","tagline":"","body":"# Game Development With Crafty – A Short Introduction With A Focus On Component-Based Programming\r\n\r\nCrafty is a game engine, allowing you to make games with JavaScript. It has a lot of features, with the component-based paradigm being especially interesting to us. But before we start to look at this, let's answer a fundamental question about why we'd need a game engine when working with JavaScript. After all, plain-vanilla JavaScript, HTML and CSS gives you everything you need already, doesn't it?\r\n\r\n## Why would you use a game engine at all?\r\nThe answer is easy: Many parts of game development are the same for each game, for example: The way input is taken from the keyboard, touch screen or mouse, graphics that are preloaded, shown and animated, sounds that have to be loaded and played or collisions between entities in the game world. A game engine provides easy ways to do handle those common things, leading to faster development – and also to less bugs, because it has been tried and actively used by many other developers.\r\n\r\nNow that we’ve established why to use a game engine, let’s talk about what Crafty gives us.\r\n\r\n## Features of Crafty\r\nFirst off, Crafty is cross-platform compatible: Sometimes, things are handled differently amongst browsers. By using a library like Crafty, you mostly don’t have to care about that anymore, because in case of doubt Crafty chooses the correct browser-specific way itself and falls back to alternatives if the best way isn’t possible in a browser.\r\n\r\nFurthermore, it provides you with multiple ways to give your game structure. That keeps the code cleaner (especially if you’re new to game development and aren’t experienced in organizing paradigms yet) and furthermore allows other Crafty developers to understand your code quicker. The main three structure-providing features are:\r\n\r\n* Scenes: In games are usually many different game states like the Menu, an Options screen, the part where you’re actually playing, a Highscore screen and many more. Those have different content and functions and should be kept separate, and you should be easily able to switch to a clean copy of them – and that’s what scenes are.\r\n* Entity Component System: This is a special way of organizing and reusing code instead of inheritance. The second part of this document will talk about this in more detail.\r\n* Event: Events provide an easy way to inform other parts of the game that something has happened. The second part will contain an example for that as well.\r\n\r\nThere are also lots of little helpers. Two examples:\r\n\r\n* Collision Detection: This is useful for all kinds of games, for example to determine whether a player is standing on a platform or if a spaceship was hit by a projectile. For certain collision types there’s also additional information, for example how much overlap there is, what the collision normal is et cetera.\r\n* Sprite Maps: Those make loading and showing images easier by packing lots of them into a big picture. It also allows for easy animations.\r\n\r\nCrafty also leaves you the choice between the Canvas or the Document Object Model:\r\n\r\n* The Canvas is an HTML element in which content is rendered. The elements are saved inside Crafty itself, so there are no direct HTML elements for the entities. They are directly drawn inside the Canvas – which of course also means that you can only draw inside the Canvas.\r\n* When using the DOM, each Crafty entity is a div HTML element and directly part of the website. Depending on your game, either might be preferable – the big plus of the DOM is that you are able to draw anywhere on the web page. This made the little toy that I made with Crafty possible – I’ll show it later.\r\n\r\nThere are three more questions that are important when choosing an engine (or any library): Is it still actively developed, does it have an active community and is it well documented? Active development ensures that new features will follow and more importantly that any bugs you encounter will probably still be fixed. An active community gives you the opportunity to ask questions, get help when you are stuck and by browsing the forum and other projects you can learn lots of new things. Why good documentation is a good thing doesn’t need an explanation.  Crafty has all of these three. (I’m missing good tutorials though.)\r\n\r\nNow that we’ve talked about Crafty in general, let’s dive in one topic in particular: What Component-based programming is and how it can help with your code organization.\r\n\r\n## Component-based Programming\r\nA common way to organize the different entities in a game is inheritance. Let’s take this structure as an example, with deeper elements being child classes of their respective parent elements:\r\n\r\n```\r\n* VisualEntity\r\n  * PhysicsEntity\r\n    * Player\r\n    * Enemy\r\n  * GuiEntity\r\n    * GuiText\r\n```\r\n\r\nThis works pretty well so far. Everything is shown on the screen, so everything inherits from VisualEntity. Then there are some elements directly physically interacting in the game world and will scroll with it when the camera moves, like a Player or an Enemy, while others like a Text just need to be drawn and will always stay on camera.\r\n\r\nLet’s assume we will also have a vanishing enemy now that disappears when the player gets too close. And because the vanishing looks kind of cool, we also want the same effect for GUI-Text. The new structure is:\r\n\r\n```\r\n* VisualEntity\r\n  * PhysicsEntity\r\n    * Player\r\n    * Enemy\r\n      * VanishingEnemy\r\n  * GuiEntity\r\n    * GuiText\r\n      * VanishingGuiText\r\n```\r\n\r\nOh. So we have two new classes now that do nearly the same, just for different parents. Of course we can have the vanishing code in an extra class and access it from VanishingEnemy and VanishingGuiText (that’s 3 classes now, but at least less code duplication!) or even additionally make an interface that the external VanishingGeneral class can use so we don’t have to write the access code in VanishingEnemy and VanishingGuiText (that’s 3 classes and an interface now. Uh…).\r\n\r\nAnd what if we want Text that is shown in the game world and scrolls with the camera, for example? That’s not really “Physical” though, so we’d need to split an IngameEntity off from PhysicalEntity. That would be:\r\n\r\n```\r\n* VisualEntity\r\n  * IngameEntity\r\n    * PhysicsEntity\r\n      * Player\r\n      * Enemy\r\n        * VanishingEnemy\r\n    * IngameText\r\n  * GuiEntity\r\n    * GuiText\r\n      * VanishingGuiText\r\n```\r\n\r\nThe inheritance-based approach has a lot of flexibility problems – and that’s where the component-based model enters the stage.\r\n\r\nIn component-based programming you don’t have a big inheritance structure. Instead, every entity instance is of a common type (for the sake of this example, let’s call it ComponentEntity) which holds a list of components.\r\n\r\nOur example above could for example contain these components which are actual classes:\r\n\r\n* ImageRenderer\r\n* TextRenderer\r\n* Vanishing\r\n* IngameScrolling\r\n* Physics\r\n* PlayerControl\r\n* EnemyControl\r\n\r\nOut of those, we can easily form those instances:\r\n\r\n* Player\r\n  * ImageRenderer\r\n  * IngameScrolling\r\n  * Physics\r\n  * PlayerControl\r\n* Enemy\r\n  * ImageRenderer\r\n  * IngameScrolling\r\n  * Physics\r\n  * EnemyControl\r\n* VanishingEnemy\r\n  * ImageRenderer\r\n  * IngameScrolling\r\n  * Physics\r\n  * EnemyControl\r\n  * Vanishing\r\n* IngameText\r\n  * TextRenderer\r\n  * IngameScrolling\r\n* GuiText\r\n  * TextRenderer\r\n  * Gui\r\n* VanishingGuiText\r\n  * TextRenderer\r\n  * Gui\r\n  * Vanishing\r\n* GuiImage\r\n  * ImageRenderer\r\n  * Gui\r\n\r\nWith a smaller amount of classes, we’ve achieved greater flexibility. Components usually have a way to access or require each other which is also present in Crafty.\r\n\r\nApart from the flexibility, the way components are made forces you to think about small, modular classes, which improves readability.\r\n\r\nIn Crafty, you’d create an entity instance like this:\r\n```javascript\r\nvar entity = Crafty.e(\"2D, DOM, Color, Twoway\");\r\nentity.attr({ x: 20, y: 100, w: 10, h: 100 });\r\nentity.color('rgb(255,0,0)'); \r\nentity.twoway(3);\r\n```\r\n\r\nThis makes an entity with the components “2D”, “DOM”, “Color” and “Twoway” (which allows the entity to be steered in two directions) and then configures some of the components which take parameters.\r\n\r\nYou can also create components yourself. Let’s say that we want the entity to have a random position at the beginning:\r\n\r\n```javascript\r\nvar entity = Crafty.e(\"2D, DOM, Color, Twoway\");\r\nentity.attr({ x: 20, y: 100, w: 10, h: 100 });\r\nentity.color('rgb(255,0,0)'); \r\nentity.twoway(3);\r\nvar entity = Crafty.e(\"2D, DOM, Color, Twoway, RandomPosition\")\r\nentity.attr({ w: 10, h: 100 }) \r\nentity.randomize(); \r\nentity.color('rgb(255,0,0)');\r\nentity.twoway(3);\r\n```\r\n\r\nA very cool feature of components is that we can now think about entities as “things that have certain components/properties”. For example if we had a fire, we could do this:\r\n\r\n```javascript\r\nCrafty(\"Flammable\").each(function() {\r\n\t// Check distance\r\n\t// Possibly set on flames\r\n}\r\n```\r\n\r\nBut what if a component wants to be informed of something happening by another component? It would be extremely inflexible to hardwire them as you can’t be sure who wants to be informed when writing your code. Luckily, Crafty contains “events”.\r\n\r\nLet’s say we have a Player which can collect coins. The GUI wants to know when he collects one to update a counter, and the SoundManager wants to play a “pling” sound. They both would ask the player coin collecting component to subscribe them to the “collected coin” event. Later on, when the player collects a coin, the “collected coin” event gets triggered, and everybody who subscribed gets informed via a method call.\r\n\r\nAnother example: The player Collision component registers a collision, sends out a “collided” event with the additional information that it collided with a platform, and the subscribed Physics component sets the player’s current falling speed to 0.\r\n\r\nIn Crafty, events are extremely easy to handle:\r\n\r\n```javascript\r\nCrafty.bind(\"PlayerCollided\", function(otherThing) {\r\n\talert(\"PlayerCollided with \" + otherThing.name);\r\n});\r\nCrafty.trigger(\"PlayerCollided\", platform);\r\n```\r\n\r\nYou just call Crafty.bind to bind a function to a named event, and then later you trigger that event which every argument you want to call – in this example, which platform the player collided with.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}